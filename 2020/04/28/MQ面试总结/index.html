<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> “MQ面试总结” · Hexo</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="https://github.com/xxxxxx" target="_blank" class="nav-link">github</a></li><li class="nav-list-item"><a href="https://coding.net/u/xxxxxx" target="_blank" class="nav-link">coding</a></li><li class="nav-list-item"><a href="http://weibo.com/xxxxxx" target="_blank" class="nav-link">weibo</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2020/04/28/MQ%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link">“MQ面试总结”</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/面试/" class="post-tag-link">面试</a></li></ul><div class="post-time">Tuesday, April 28th 2020</div></div><div class="post-content"><p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠性、广播、流量控制、最终一致性等一系列功能，成分异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。</p>
<a id="more"></a>

<h2 id="MQ的组成"><a href="#MQ的组成" class="headerlink" title="MQ的组成"></a>MQ的组成</h2><p>1、Broker：消息服务器，作为server提供消息核心服务；<br>2、Producer：消息生产者，业务的发起方，负责生产消息传输给Broker<br>3、Consumer：消息消费者，业务的处理方，负责从Broker获取消息并进行业务逻辑处理；<br>4、Topic：主题，发布订阅模式下的统一汇集地，不同生产者向Topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播；<br>5、Queue：队列，点对点模式下，特定的生产者向特定Queue发送消息，消费者订阅特定的Queue完成指定消息的接收；<br>6、Message：消息体，根据不同通讯协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传递。</p>
<h2 id="消息的传递类型"><a href="#消息的传递类型" class="headerlink" title="消息的传递类型"></a>消息的传递类型</h2><p>1、点对点：使用Queue作为通讯载体，消息生产者生成消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，Queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只有一个消费者可以消费。<br><img src="/images/MQ-1.png" height="555px"><br>2、发布/订阅：使用Topic作为通讯载体，消息生产者（发布）将消息发布到Topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到Topic的消息会被所有的订阅者消费。<br><img src="/images/MQ-2.png" height="555px"><br>两者的区别：Queue实现负载均衡，将Producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。<br>       Topic实现了发布和订阅，当你发布一个消息，所有订阅这个Topic的服务都能的得到这个消息，所以1到N个订阅者都能得到一个消息的拷贝。</p>
<h2 id="MQ优缺点"><a href="#MQ优缺点" class="headerlink" title="MQ优缺点"></a>MQ优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、解耦：一个业务需要多个模块共同实现，或者一条消息有多个系统需要对应处理，只需要主业务完成之后，发送一条MQ，其余模块消费MQ消息，即可实现业务，降低模块之间的耦合。<br>2、异步：主业务执行结束后从属业务通过MQ异步执行，减低业务的响应时间，提高用户体验。<br>3、消峰：高并发情况下，MQ-client提供拉模式，根据自己的处理能力，每隔一段时间或每次拉取若干条消息，实施流控，达到下游自我保护的作用，可以提高高峰期业务处理的能力，避免系统瘫痪。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、系统可用性降低：系统引入的外部依赖越多，越容易挂掉，需考虑MQ瘫痪的情况。<br>2、系统复杂性提高：需要考虑消息丢失、消息重复消费、消息传递的顺序性等问题。<br>3、系统存在一致性问题：需考虑主、从业务一致性处理。</p>
<h2 id="不同MQ之间的区别"><a href="#不同MQ之间的区别" class="headerlink" title="不同MQ之间的区别"></a>不同MQ之间的区别</h2><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">ActiveMQ</th>
<th align="center">RabbitMQ</th>
<th align="center">RocketMQ</th>
<th align="center">Kafka</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单机吞吐量</td>
<td align="center">万级</td>
<td align="center">万级</td>
<td align="center">十万级</td>
<td align="center">十万级</td>
</tr>
<tr>
<td align="center">Topic数量对吞吐量的影响</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Topic可达到几百、几千的级别，吞吐量后有较小幅度的下降（优势）</td>
<td align="center">Topic从几百到几千时，吞吐量会大幅度下降</td>
</tr>
<tr>
<td align="center">时效性</td>
<td align="center">毫秒级</td>
<td align="center">微秒级（优势）</td>
<td align="center">毫秒级</td>
<td align="center">毫秒级</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">高，基于主从架构实现高可用性</td>
<td align="center">高，基于主从架构实现高可用性</td>
<td align="center">非常高，分布式架构</td>
<td align="center">非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td align="center">消息可靠性</td>
<td align="center">有较低的概率丢失数据</td>
<td align="center"></td>
<td align="center">经过参数优化设置，可以做到零丢失</td>
<td align="center">经过参数优化设置，可以做到零丢失</td>
</tr>
<tr>
<td align="center">功能支持</td>
<td align="center">MQ领域的功能极其完备</td>
<td align="center">基于erlang开发，所以并发能力很强，性能机器好，延时很低</td>
<td align="center">MQ功能较为完善，还是分布式的，扩展性好</td>
<td align="center">功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td align="center">优势</td>
<td align="center">非常成熟，功能强大在业内大量的公司以及项目中都有应用</td>
<td align="center">erlang语言开发，性能极其好，延时很低。吞吐量到万级，MQ功能比较完备。开源提供的管理界面非常棒。社区相对比较活跃，几乎每个月都发布几个版本。国内一些互联网公司用的也比较多</td>
<td align="center">接口简单易用，阿里大规模应用过。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展很方便，社区维护还可以，可靠性和可用性都不错，还可以支持大规模的Topic数量，支持复杂MQ业务场景。Java编写，源码便于阅读</td>
<td align="center">Kafka仅仅提供较少的核心功能，但是提供超高的吞吐量，毫秒级的延迟，极高的可用性和可靠性，分布式易扩展。Kafka最好是支撑较少的Topic数量，以保证其超高的吞吐量</td>
</tr>
<tr>
<td align="center">劣势</td>
<td align="center">偶尔会有较低概率丢失消息。社区活跃度逐渐越低、国内应用也越来越少，官方对ActiveMQ 5.x维护越来越少，几个月才发布一个版本。主要基于解耦和异步来用，较少在大规模吞吐的场景中使用</td>
<td align="center">实现机制比较重，吞吐量相比低一些。erlang语言开发，很难有实力去源码级别研究与定制。RabbitMQ集群动态扩展很麻烦</td>
<td align="center">社区活跃度相对一般，文档相对简单一些，接口不是按照标准JMS规范，有些系统要迁移时需要大量修改代码</td>
<td align="center">消息可重复消费，会对消息准确性造成极其细微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略，这个特性天然适合大数据实时计算以及日志采集</td>
</tr>
</tbody></table>
<p>综上所述：中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择；大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，几乎是全世界这个领域的事实性规范。</p>
</div></article><div class="pagination"><span class="pagination-prev">PREV</span><span class="pagination-next">NEXT</span></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/MQ%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">“MQ面试总结”</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2020 <a href="/">John Doe</P></div><div class="power"><p><a href="http://pinggod.com/" target="_blank" rel="noopener">Sean Sun</a>, 
<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>, 
<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>, 
<a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80781234-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?ee75cf111111aa99f8540efa2570970";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>