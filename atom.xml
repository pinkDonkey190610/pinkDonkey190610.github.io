<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pinkDonkey</title>
  
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-29T15:49:53.350Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>pinkDonkey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>“MQ面试总结”</title>
    <link href="http://yoursite.com/2020/04/28/MQ%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/28/MQ%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-28T08:29:48.000Z</published>
    <updated>2020-04-29T15:49:53.350Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠性、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。</p><a id="more"></a><h2 id="MQ的组成"><a href="#MQ的组成" class="headerlink" title="MQ的组成"></a>MQ的组成</h2><p>1、Broker：消息服务器，作为server提供消息核心服务；<br>2、Producer：消息生产者，业务的发起方，负责生产消息传输给Broker<br>3、Consumer：消息消费者，业务的处理方，负责从Broker获取消息并进行业务逻辑处理；<br>4、Topic：主题，发布订阅模式下的统一汇集地，不同生产者向Topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播；<br>5、Queue：队列，点对点模式下，特定的生产者向特定Queue发送消息，消费者订阅特定的Queue完成指定消息的接收；<br>6、Message：消息体，根据不同通讯协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传递。</p><h2 id="消息的传递类型"><a href="#消息的传递类型" class="headerlink" title="消息的传递类型"></a>消息的传递类型</h2><p>1、点对点：使用Queue作为通讯载体，消息生产者生成消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，Queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只有一个消费者可以消费。<br><img src="/images/MQ-1.png" height="555px"><br>2、发布/订阅：使用Topic作为通讯载体，消息生产者（发布）将消息发布到Topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到Topic的消息会被所有的订阅者消费。<br><img src="/images/MQ-2.png" height="555px"><br>两者的区别：Queue实现负载均衡，将Producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者；Topic实现了发布和订阅，当你发布一个消息，所有订阅这个Topic的服务都能的得到这个消息，所以1到N个订阅者都能得到一个消息的拷贝。</p><h2 id="MQ优缺点"><a href="#MQ优缺点" class="headerlink" title="MQ优缺点"></a>MQ优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、解耦：一个业务需要多个模块共同实现，或者一条消息有多个系统需要对应处理，只需要主业务完成之后，发送一条MQ，其余模块消费MQ消息，即可实现业务，降低模块之间的耦合。<br>2、异步：主业务执行结束后从属业务通过MQ异步执行，减低业务的响应时间，提高用户体验。<br>3、消峰：高并发情况下，MQ-client提供拉模式，根据自己的处理能力，每隔一段时间或每次拉取若干条消息，实施流控，达到下游自我保护的作用，可以提高高峰期业务处理的能力，避免系统瘫痪。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、系统可用性降低：系统引入的外部依赖越多，越容易挂掉，需考虑MQ瘫痪的情况。<br>2、系统复杂性提高：需要考虑消息丢失、消息重复消费、消息传递的顺序性等问题。<br>3、系统存在一致性问题：需考虑主、从业务一致性处理。</p><h2 id="不同MQ之间的区别"><a href="#不同MQ之间的区别" class="headerlink" title="不同MQ之间的区别"></a>不同MQ之间的区别</h2><table><thead><tr><th align="center">特性</th><th align="center">ActiveMQ</th><th align="center">RabbitMQ</th><th align="center">RocketMQ</th><th align="center">Kafka</th></tr></thead><tbody><tr><td align="center">单机吞吐量</td><td align="center">万级</td><td align="center">万级</td><td align="center">十万级</td><td align="center">十万级</td></tr><tr><td align="center">Topic数量对吞吐量的影响</td><td align="center"></td><td align="center"></td><td align="center">Topic可达到几百、几千的级别，吞吐量后有较小幅度的下降（优势）</td><td align="center">Topic从几百到几千时，吞吐量会大幅度下降</td></tr><tr><td align="center">时效性</td><td align="center">毫秒级</td><td align="center">微秒级（优势）</td><td align="center">毫秒级</td><td align="center">毫秒级</td></tr><tr><td align="center">可用性</td><td align="center">高，基于主从架构实现高可用性</td><td align="center">高，基于主从架构实现高可用性</td><td align="center">非常高，分布式架构</td><td align="center">非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td align="center">消息可靠性</td><td align="center">有较低的概率丢失数据</td><td align="center"></td><td align="center">经过参数优化设置，可以做到零丢失</td><td align="center">经过参数优化设置，可以做到零丢失</td></tr><tr><td align="center">功能支持</td><td align="center">MQ领域的功能极其完备</td><td align="center">基于erlang开发，所以并发能力很强，性能机器好，延时很低</td><td align="center">MQ功能较为完善，还是分布式的，扩展性好</td><td align="center">功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td align="center">优势</td><td align="center">非常成熟，功能强大在业内大量的公司以及项目中都有应用</td><td align="center">erlang语言开发，性能极其好，延时很低。吞吐量到万级，MQ功能比较完备。开源提供的管理界面非常棒。社区相对比较活跃，几乎每个月都发布几个版本。国内一些互联网公司用的也比较多</td><td align="center">接口简单易用，阿里大规模应用过。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展很方便，社区维护还可以，可靠性和可用性都不错，还可以支持大规模的Topic数量，支持复杂MQ业务场景。Java编写，源码便于阅读</td><td align="center">Kafka仅仅提供较少的核心功能，但是提供超高的吞吐量，毫秒级的延迟，极高的可用性和可靠性，分布式易扩展。Kafka最好是支撑较少的Topic数量，以保证其超高的吞吐量</td></tr><tr><td align="center">劣势</td><td align="center">偶尔会有较低概率丢失消息。社区活跃度逐渐越低、国内应用也越来越少，官方对ActiveMQ 5.x维护越来越少，几个月才发布一个版本。主要基于解耦和异步来用，较少在大规模吞吐的场景中使用</td><td align="center">实现机制比较重，吞吐量相比低一些。erlang语言开发，很难有实力去源码级别研究与定制。RabbitMQ集群动态扩展很麻烦</td><td align="center">社区活跃度相对一般，文档相对简单一些，接口不是按照标准JMS规范，有些系统要迁移时需要大量修改代码</td><td align="center">消息可重复消费，会对消息准确性造成极其细微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略，这个特性天然适合大数据实时计算以及日志采集</td></tr></tbody></table><p>综上所述：中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择；大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，几乎是全世界这个领域的事实性规范。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠性、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
